[1mdiff --cc src/mower/main_controller.py[m
[1mindex 72290b3,36d8bf6..0000000[m
[1m--- a/src/mower/main_controller.py[m
[1m+++ b/src/mower/main_controller.py[m
[36m@@@ -511,6 -513,102 +511,105 @@@[m [mclass ResourceManager[m
          else:[m
              logger.warning("Web interface resource not available")[m
  [m
[32m++<<<<<<< HEAD[m
[32m++=======[m
[32m+     def get_home_location(self):[m
[32m+         """[m
[32m+         Get the home location.[m
[32m+         [m
[32m+         Returns:[m
[32m+             list or tuple: [latitude, longitude] of home location[m
[32m+                           or [0.0, 0.0] if not set[m
[32m+         """[m
[32m+         try:[m
[32m+             # Try to load from configuration file[m
[32m+             try:[m
[32m+                 with open(self.user_polygon_path, "r") as f:[m
[32m+                     data = json.load(f)[m
[32m+                     if "home" in data:[m
[32m+                         return data["home"][m
[32m+             except Exception as e:[m
[32m+                 logger.warning(f"Error reading home location from file: {e}")[m
[32m+             [m
[32m+             # Default location if not found[m
[32m+             return [0.0, 0.0][m
[32m+         except Exception as e:[m
[32m+             logger.error(f"Error getting home location: {e}")[m
[32m+             return [0.0, 0.0][m
[32m+     [m
[32m+     def get_boundary_points(self):[m
[32m+         """[m
[32m+         Get the currently configured boundary points.[m
[32m+         [m
[32m+         Returns:[m
[32m+             list: The boundary points as a list of [lat, lng] coordinates,[m
[32m+                  or empty list if not configured[m
[32m+         """[m
[32m+         try:[m
[32m+             path_planner = self.get_path_planner()[m
[32m+             if path_planner and hasattr(path_planner, "pattern_config"):[m
[32m+                 return path_planner.pattern_config.boundary_points[m
[32m+             [m
[32m+             # Try to load from configuration file if not in path_planner[m
[32m+             try:[m
[32m+                 with open(self.user_polygon_path, "r") as f:[m
[32m+                     data = json.load(f)[m
[32m+                     if "boundary" in data:[m
[32m+                         return data["boundary"][m
[32m+             except Exception as e:[m
[32m+                 logger.warning(f"Error reading boundary from file: {e}")[m
[32m+                 [m
[32m+             return [][m
[32m+         except Exception as e:[m
[32m+             logger.error(f"Error getting boundary points: {e}")[m
[32m+             return [][m
[32m+ [m
[32m+     def set_home_location(self, location):[m
[32m+         """[m
[32m+         Set the home location and save it to configuration.[m
[32m+         [m
[32m+         Args:[m
[32m+             location: The location as [lat, lng] or {lat, lng}[m
[32m+             [m
[32m+         Returns:[m
[32m+             bool: True if successful, False otherwise[m
[32m+         """[m
[32m+         try:[m
[32m+             # Normalize location format - handle both array and object formats[m
[32m+             if isinstance(location, dict) and 'lat' in location and 'lng' in location:[m
[32m+                 normalized_location = [location['lat'], location['lng']][m
[32m+             elif isinstance(location, (list, tuple)) and len(location) == 2:[m
[32m+                 normalized_location = location[m
[32m+             else:[m
[32m+                 logger.error(f"Invalid location format: {location}")[m
[32m+                 return False[m
[32m+                 [m
[32m+             # Load existing data[m
[32m+             data = {}[m
[32m+             try:[m
[32m+                 with open(self.user_polygon_path, "r") as f:[m
[32m+                     data = json.load(f)[m
[32m+             except Exception as e:[m
[32m+                 logger.warning(f"Error reading config file, creating new: {e}")[m
[32m+                 [m
[32m+             # Update home location[m
[32m+             data["home"] = normalized_location[m
[32m+             [m
[32m+             # Save to configuration file[m
[32m+             try:[m
[32m+                 with open(self.user_polygon_path, "w") as f:[m
[32m+                     json.dump(data, f)[m
[32m+                 logger.info(f"Home location saved: {normalized_location}")[m
[32m+                 return True[m
[32m+             except Exception as e:[m
[32m+                 logger.error(f"Failed to save home location: {e}")[m
[32m+                 return False[m
[32m+                 [m
[32m+         except Exception as e:[m
[32m+             logger.error(f"Error setting home location: {e}")[m
[32m+             return False[m
[32m+ [m
[32m++>>>>>>> ui-enhancements[m
      def get_safety_status(self):[m
          """Retrieve safety status from the sensor interface.[m
  [m
[36m@@@ -943,6 -1042,130 +1042,133 @@@[m
              self._resources["blade"].disable()[m
          logger.info("All systems halted due to emergency stop.")[m
  [m
[32m++<<<<<<< HEAD[m
[32m++=======[m
[32m+     def execute_command(self, command, params=None):[m
[32m+         """[m
[32m+         Execute a command received from the web UI.[m
[32m+ [m
[32m+         Args:[m
[32m+             command: The command name (string)[m
[32m+             params: Command parameters (dict)[m
[32m+ [m
[32m+         Returns:[m
[32m+             dict: Command result[m
[32m+         """[m
[32m+         logger.info(f"Executing command: {command} with params: {params}")[m
[32m+ [m
[32m+         if command == "manual_drive":[m
[32m+             return self._handle_manual_drive(params)[m
[32m+         elif command == "blade_on":[m
[32m+             blade = self.get_blade_controller()[m
[32m+             if blade:[m
[32m+                 blade.enable()[m
[32m+                 return {"status": "Blade enabled"}[m
[32m+         elif command == "blade_off":[m
[32m+             blade = self.get_blade_controller()[m
[32m+             if blade:[m
[32m+                 blade.disable()[m
[32m+                 return {"status": "Blade disabled"}[m
[32m+         elif command == "set_blade_speed":[m
[32m+             blade = self.get_blade_controller()[m
[32m+             if blade and "speed" in params:[m
[32m+                 speed = float(params["speed"])[m
[32m+                 blade.set_speed(speed)[m
[32m+                 return {"status": f"Blade speed set to {speed}"}[m
[32m+         elif command == "save_area":[m
[32m+             # Save mowing area boundary[m
[32m+             if params and "coordinates" in params:[m
[32m+                 path_planner = self.get_path_planner()[m
[32m+                 if path_planner:                    success = path_planner.set_boundary_points(params["coordinates"])[m
[32m+                     if success:[m
[32m+                         return {"status": "Boundary area saved successfully"}[m
[32m+                     return {"error": "Failed to save boundary area"}[m
[32m+                 return {"error": "Path planner not available"}[m
[32m+             return {"error": "Missing coordinates parameter"}[m
[32m+         elif command == "set_home":[m
[32m+             # Save home location[m
[32m+             if params and "location" in params:[m
[32m+                 success = self.set_home_location(params["location"])[m
[32m+                 if success:[m
[32m+                     return {"status": "Home location saved successfully"}[m
[32m+                 return {"error": "Failed to save home location"}[m
[32m+             return {"error": "Missing location parameter"}[m
[32m+         elif command == "generate_pattern":[m
[32m+             # Generate mowing pattern[m
[32m+             if params and "pattern_type" in params:[m
[32m+                 path_planner = self.get_path_planner()[m
[32m+                 if path_planner:[m
[32m+                     try:[m
[32m+                         pattern_type = params.get("pattern_type", "PARALLEL")[m
[32m+                         settings = params.get("settings", {})[m
[32m+                         pattern = path_planner.generate_pattern(pattern_type, settings)[m
[32m+                         if pattern:[m
[32m+                             return {[m
[32m+                                 "status": "Pattern generated successfully",[m
[32m+                                 "path": pattern,[m
[32m+                                 "coverage": 0.85  # Example coverage value[m
[32m+                             }[m
[32m+                         return {"error": "Failed to generate pattern"}[m
[32m+                     except Exception as e:[m
[32m+                         logger.error(f"Error generating pattern: {e}")[m
[32m+                         return {"error": f"Error generating pattern: {str(e)}"}[m
[32m+                 return {"error": "Path planner not available"}[m
[32m+             return {"error": "Missing pattern_type parameter"}[m
[32m+         elif command == "start_mowing":[m
[32m+             # Implement start mowing logic[m
[32m+             return {"status": "Mowing started"}[m
[32m+         elif command == "stop":[m
[32m+             # Stop all movement[m
[32m+             motor = self.get_robohat_driver()[m
[32m+             if motor:[m
[32m+                 motor.stop()[m
[32m+             return {"status": "Motors stopped"}[m
[32m+         elif command == "return_home":[m
[32m+             # Implement return home logic[m
[32m+             return {"status": "Returning home"}[m
[32m+         else:[m
[32m+             logger.warning(f"Unknown command: {command}")[m
[32m+             return {"error": f"Unknown command: {command}"}[m
[32m+ [m
[32m+     def _handle_manual_drive(self, params):[m
[32m+         """[m
[32m+         Handle manual drive commands from the joystick.[m
[32m+ [m
[32m+         Args:[m
[32m+             params: Dict containing 'forward' and 'turn' values between -1.0 and 1.0[m
[32m+ [m
[32m+         Returns:[m
[32m+             dict: Command result[m
[32m+         """[m
[32m+         if params is None or "forward" not in params or "turn" not in params:[m
[32m+             return {"error": "Missing required parameters"}[m
[32m+ [m
[32m+         try:[m
[32m+             forward = float(params["forward"])[m
[32m+             turn = float(params["turn"])[m
[32m+ [m
[32m+             # Ensure values are within allowed range[m
[32m+             forward = max(-1.0, min(1.0, forward))[m
[32m+             turn = max(-1.0, min(1.0, turn))[m
[32m+ [m
[32m+             motor = self.get_robohat_driver()[m
[32m+             if motor:[m
[32m+                 # Set the state to MANUAL when manual drive is used[m
[32m+                 if forward != 0.0 or turn != 0.0:[m
[32m+                     self.current_state = SystemState.MANUAL_CONTROL[m
[32m+ [m
[32m+                 # Convert joystick values to steering/throttle for the motor driver[m
[32m+                 motor.run(turn, forward)[m
[32m+                 logger.debug(f"Manual drive: forward={forward}, turn={turn}")[m
[32m+                 return {"status": "ok", "forward": forward, "turn": turn}[m
[32m+             else:[m
[32m+                 logger.error("Motor driver not available")[m
[32m+                 return {"error": "Motor driver not available"}[m
[32m+         except Exception as e:[m
[32m+             logger.error(f"Error in manual drive: {e}")[m
[32m+             return {"error": f"Error in manual drive: {str(e)}"}[m
[32m+ [m
[32m++>>>>>>> ui-enhancements[m
  [m
  def main():[m
      """[m
